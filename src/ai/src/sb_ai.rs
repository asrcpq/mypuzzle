// slightly better AI
// observe one block forward
use tttz_protocol::{Display, KeyType, BoardMsg};
use tttz_ruleset::*;
use tttz_mpboard::{Block, Board};

use crate::ai_utils::*;
use crate::ai::Thinker;

use std::collections::VecDeque;

pub struct SbAi {
	test_board: Board,
	heights: [u8; 10],
	
	hole_weight: f32,
	height_weight: f32,
	attack_weight: f32,
}

impl Default for SbAi {
	fn default() -> Self {
		SbAi {
			test_board: Board::new(0),
			heights: [40u8; 10],

			hole_weight: 1.0,
			height_weight: 1.0,
			attack_weight: 0.1,
		}
	}
}

impl SbAi {
	// think2 is called for the given first block
	// return value
	fn think2(
		&mut self,
		twist: bool,
	) -> f32 {
		// first just simulate basic_ai(without cover)
		let mut delta_heights = [0; 4];
		let mut block_count = [0; 4];
		let dx = self.test_board.tmp_block.pos.0;
		let height = self.test_board.tmp_block.pos.1;

		let mut hole: i32 = 0;
		let pos = self.test_board.tmp_block.getpos_internal();
		for block in 0..4 {
			let dh = self.heights[dx as usize + pos[block].0 as usize] as i8
				- pos[block].1 as i8 - height as i8;
			block_count[pos[block].0 as usize] += 1;
			if dh < 0 {
				hole -= 1;
			} else if dh > delta_heights[pos[block].0 as usize] {
				delta_heights[pos[block].0 as usize] = dh;
			}
		}
		for block in 0..4 {
			if delta_heights[block] > block_count[block] {
				hole += 1;
			}
		}
		let atk = self.test_board.hard_drop_dry_with_twist(twist as u32 * 2);
		let score = (
			height as f32 +
			MCH[self.test_board.tmp_block.code as usize][self.test_board.tmp_block.rotation as usize]
		) * self.height_weight -
		hole as f32 * self.hole_weight +
		atk as f32 * self.attack_weight;
		score
	}

	pub fn think1(&mut self, depth: u32) -> (f32, GenerateKeyParam) {
		self.heights = get_height_and_hole(&self.test_board.display).0;

		let mut max_value: f32 = f32::NEG_INFINITY;
		let mut gkp: GenerateKeyParam = Default::default();
		// we should not really optimize first block since
		// possible twists can be filtered out easily
		for id in 0..2 {
			for rot in 0..4i8 {
				let (possible_pos, _posx, _posy) = convolve_height(
					&self.heights,
					self.test_board.tmp_block.code,
					rot,
				);
				self.test_board.tmp_block.rotation = rot;
				for (dx, height) in possible_pos
					.iter()
					.map(|(x, y)| (*x as i32, *y as i32)) {
					// we further try rotate and move
					self.test_board.tmp_block.pos.0 = dx;
					self.test_board.tmp_block.pos.1 = height;
					// too high, just skip
					if height <= 1 { continue }
					if !self.test_board.tmp_block.test(&self.test_board) {
						// let heights = get_height_and_hole(&self.test_board.display).0;
						panic!("Invalid pos generated by convolution: {}", depth);
					};

					// generate possible blocks
					let revert_block = self.test_board.tmp_block.clone();
					// now we are iterating the operations after soft drop
					for key_type in [
						KeyType::Nothing,
						KeyType::Left,
						KeyType::Right,
						KeyType::Rotate,
						KeyType::RotateReverse,
						KeyType::RotateFlip,
					].iter() {
						// TODO: handle_msg is an interface for interactive gaming thus inefficient
						self.test_board.handle_msg(BoardMsg::KeyEvent(*key_type));
						let mut flag = true;
						// completely failed operation
						if self.test_board.tmp_block.pos.0 == revert_block.pos.0 &&
							self.test_board.tmp_block.rotation == revert_block.rotation {
							flag = false;
						}

						// can move up/down
						self.test_board.tmp_block.pos.1 += 1;
						if self.test_board.tmp_block.test(&self.test_board) {
							flag = false;
						}
						self.test_board.tmp_block.pos.1 -= 2;
						if self.test_board.tmp_block.test(&self.test_board) {
							flag = false;
						}

						if flag || *key_type == KeyType::Nothing {
							self.test_board.tmp_block.pos.1 += 1;
							// left/right move for twist test
							// we won't make a mini-twist test for efficiency
							self.test_board.tmp_block.pos.0 -= 1;
							let twist = if self.test_board.tmp_block.test(&self.test_board) {
								self.test_board.tmp_block.pos.0 += 1;
								false
							} else {
								self.test_board.tmp_block.pos.0 += 2;
								if self.test_board.tmp_block.test(&self.test_board) {
									self.test_board.tmp_block.pos.0 -= 1;
									false
								} else {
									self.test_board.tmp_block.pos.0 -= 1;
									true
								}
							};
							let value = if depth == 1 {
								let mut sbai2: SbAi = self.sbai_clone();
								let value1 = self.think2(
									twist,
								);
								sbai2.test_board.hard_drop();
								let (value2, _) = sbai2.think1(0);
								value1 + value2
							} else {
								self.think2(
									twist,
								)
							};
							if value > max_value {
								// eprintln!(
								// 	"atk {}, score {} overtake {} at dx: {}, rot: {}",
								// 	self.test_board.attack_pool,
								// 	value,
								// 	max_value,
								// 	dx,
								// 	rot,
								// );
								max_value = value;
								if id == 0 {
									gkp.hold_swap = false
								} else {
									gkp.hold_swap = true
								}
								gkp.code = self.test_board.tmp_block.code;
								gkp.rotation = rot;
								gkp.dx = dx;
								gkp.post_key = *key_type;
							}
						}
						self.test_board.tmp_block = revert_block.clone();
					}
				}
			}
			let tmp = self.test_board.display.hold;
			self.test_board.display.hold = self.test_board.tmp_block.code;
			self.test_board.tmp_block = Block::new(tmp);
		}
		(max_value, gkp)
	}

	fn set_board(&mut self, display: Display) {
		self.test_board.tmp_block = Block::decompress(&display.tmp_block);
		self.test_board.display = display;
		self.test_board.rg.bag =
			self.test_board
				.display
				.bag_preview
				.iter()
				.map(|x| *x)
				.collect();
	}

	fn sbai_clone(&self) -> SbAi {
		let mut sb_ai: SbAi = Default::default();
		sb_ai.test_board.tmp_block = self.test_board.tmp_block.clone();
		sb_ai.test_board.display = self.test_board.display.clone();
		sb_ai.test_board.rg.bag = self.test_board.rg.bag.clone();
		sb_ai
	}
}

impl Thinker for SbAi {
	fn main_think(&mut self, display: Display) -> VecDeque<KeyType> {
		if display.hold == 7 {
			let mut ret = VecDeque::new();
			ret.push_back(KeyType::Hold);
			return ret
		}
		self.set_board(display);
		let gkp = self.think1(1).1;
		generate_keys(gkp)
	}
}

#[cfg(test)]
mod test {
	use super::*;

	#[test]
	fn test_obvious_tspin() {
		let mut display = Display::generate_solidlines([3, 3, 0, 1, 3, 6, 7, 8, 9, 10]);
		display.color[38][1] = 7;
		display.tmp_block = Block::new(5).compress();
		display.hold = 5;
		display.bag_preview = [5; 6];
		let mut sb_ai: SbAi = Default::default();
		let mut ops = sb_ai.main_think(display);
		println!("{:?}", ops);
		ops.pop_back();
		let x = ops.pop_back().unwrap();
		assert_eq!(x, KeyType::Rotate);
		let x = ops.pop_back().unwrap();
		assert_eq!(x, KeyType::SoftDrop);
	}
}
